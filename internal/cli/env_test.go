package cli

import (
	"bytes"
	"os"
	"strings"
	"testing"

	"github.com/dk/varnish/internal/project"
	"github.com/dk/varnish/internal/registry"
	"github.com/dk/varnish/internal/store"
)

func TestRunEnvDryRun(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	projectDir, cleanupProject := setupProjectForEnv(t, "envdry")
	defer cleanupProject()

	store, _ := store.Load()
	store.Set("envdry.db.host", "localhost")
	store.Set("envdry.db.port", "5432")
	if err := store.Save(); err != nil {
		t.Fatalf("failed to save: %v", err)
	}

	origWd, _ := os.Getwd()
	defer func() { _ = os.Chdir(origWd) }()
	if err := os.Chdir(projectDir); err != nil {
		t.Fatalf("failed to chdir: %v", err)
	}

	var stdout, stderr bytes.Buffer
	err := runEnv([]string{"--dry-run"}, &stdout, &stderr)
	if err != nil {
		t.Fatalf("runEnv --dry-run error: %v", err)
	}

	output := stdout.String()
	if !strings.Contains(output, "DB_HOST=localhost") {
		t.Errorf("expected 'DB_HOST=localhost' in output, got: %s", output)
	}
	if !strings.Contains(output, "DB_PORT=5432") {
		t.Errorf("expected 'DB_PORT=5432' in output, got: %s", output)
	}
	if !strings.Contains(output, "Generated by varnish") {
		t.Errorf("expected header comment, got: %s", output)
	}
}

func TestRunEnvWriteFile(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	projectDir, cleanupProject := setupProjectForEnv(t, "envwrite")
	defer cleanupProject()

	store, _ := store.Load()
	store.Set("envwrite.api.key", "secret123")
	if err := store.Save(); err != nil {
		t.Fatalf("failed to save: %v", err)
	}

	origWd, _ := os.Getwd()
	defer func() { _ = os.Chdir(origWd) }()
	if err := os.Chdir(projectDir); err != nil {
		t.Fatalf("failed to chdir: %v", err)
	}

	var stdout, stderr bytes.Buffer
	err := runEnv([]string{"--force"}, &stdout, &stderr)
	if err != nil {
		t.Fatalf("runEnv --force error: %v", err)
	}

	// Check file was created
	content, err := os.ReadFile(".env")
	if err != nil {
		t.Fatalf("failed to read .env: %v", err)
	}

	if !strings.Contains(string(content), "API_KEY=secret123") {
		t.Errorf("expected 'API_KEY=secret123' in .env, got: %s", string(content))
	}
}

func TestRunEnvCustomOutput(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	projectDir, cleanupProject := setupProjectForEnv(t, "envcustom")
	defer cleanupProject()

	store, _ := store.Load()
	store.Set("envcustom.test.key", "value")
	if err := store.Save(); err != nil {
		t.Fatalf("failed to save: %v", err)
	}

	origWd, _ := os.Getwd()
	defer func() { _ = os.Chdir(origWd) }()
	if err := os.Chdir(projectDir); err != nil {
		t.Fatalf("failed to chdir: %v", err)
	}

	var stdout, stderr bytes.Buffer
	err := runEnv([]string{"--output", ".env.local"}, &stdout, &stderr)
	if err != nil {
		t.Fatalf("runEnv --output error: %v", err)
	}

	// Check custom file was created
	if _, err := os.Stat(".env.local"); os.IsNotExist(err) {
		t.Error("expected .env.local to be created")
	}

	content, _ := os.ReadFile(".env.local")
	if !strings.Contains(string(content), "TEST_KEY=value") {
		t.Errorf("expected 'TEST_KEY=value' in .env.local, got: %s", string(content))
	}
}

func TestRunEnvExistsNoForce(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	projectDir, cleanupProject := setupProjectForEnv(t, "envexists")
	defer cleanupProject()

	store, _ := store.Load()
	store.Set("envexists.key", "value")
	if err := store.Save(); err != nil {
		t.Fatalf("failed to save: %v", err)
	}

	origWd, _ := os.Getwd()
	defer func() { _ = os.Chdir(origWd) }()
	if err := os.Chdir(projectDir); err != nil {
		t.Fatalf("failed to chdir: %v", err)
	}

	// Create existing .env
	if err := os.WriteFile(".env", []byte("existing"), 0644); err != nil {
		t.Fatalf("failed to write .env: %v", err)
	}

	var stdout, stderr bytes.Buffer
	err := runEnv([]string{}, &stdout, &stderr)
	if err == nil {
		t.Error("expected error when .env exists without --force")
	}
	if !strings.Contains(err.Error(), "already exists") {
		t.Errorf("expected 'already exists' error, got: %v", err)
	}
}

func TestRunEnvForceOverwrite(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	projectDir, cleanupProject := setupProjectForEnv(t, "envforce")
	defer cleanupProject()

	store, _ := store.Load()
	store.Set("envforce.new.key", "newvalue")
	if err := store.Save(); err != nil {
		t.Fatalf("failed to save: %v", err)
	}

	origWd, _ := os.Getwd()
	defer func() { _ = os.Chdir(origWd) }()
	if err := os.Chdir(projectDir); err != nil {
		t.Fatalf("failed to chdir: %v", err)
	}

	// Create existing .env
	if err := os.WriteFile(".env", []byte("old content"), 0644); err != nil {
		t.Fatalf("failed to write .env: %v", err)
	}

	var stdout, stderr bytes.Buffer
	err := runEnv([]string{"--force"}, &stdout, &stderr)
	if err != nil {
		t.Fatalf("runEnv --force error: %v", err)
	}

	content, _ := os.ReadFile(".env")
	if strings.Contains(string(content), "old content") {
		t.Error("old content should have been overwritten")
	}
	if !strings.Contains(string(content), "NEW_KEY=newvalue") {
		t.Errorf("expected new content, got: %s", string(content))
	}
}

func TestRunEnvNoConfig(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	projectDir, err := os.MkdirTemp("", "varnish-project-*")
	if err != nil {
		t.Fatalf("failed to create project dir: %v", err)
	}
	defer os.RemoveAll(projectDir)

	origWd, _ := os.Getwd()
	defer func() { _ = os.Chdir(origWd) }()
	if err := os.Chdir(projectDir); err != nil {
		t.Fatalf("failed to chdir: %v", err)
	}

	var stdout, stderr bytes.Buffer
	err = runEnv([]string{}, &stdout, &stderr)
	if err == nil {
		t.Error("expected error when no config exists")
	}
}

func TestRunEnvMissingVarsWarning(t *testing.T) {
	cleanup := setupTestEnv(t)
	defer cleanup()

	projectDir, cleanupProject := setupProjectForEnv(t, "envmissing")
	defer cleanupProject()

	// Don't add any variables to store - they'll be missing

	origWd, _ := os.Getwd()
	defer func() { _ = os.Chdir(origWd) }()
	if err := os.Chdir(projectDir); err != nil {
		t.Fatalf("failed to chdir: %v", err)
	}

	var stdout, stderr bytes.Buffer
	err := runEnv([]string{"--dry-run"}, &stdout, &stderr)
	if err != nil {
		t.Fatalf("runEnv error: %v", err)
	}

	// Should warn about missing variables
	if !strings.Contains(stderr.String(), "missing") {
		t.Errorf("expected warning about missing variables, stderr: %s", stderr.String())
	}
}

func TestQuoteEnvValue(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"simple", "simple"},
		{"with space", "\"with space\""},
		{"with'quote", "\"with'quote\""},
		{"with\"doublequote", "\"with\\\"doublequote\""},
		{"with$dollar", "\"with\\$dollar\""},
		{"with`backtick", "\"with\\`backtick\""},
		{"with\\backslash", "\"with\\\\backslash\""},
		{"", "\"\""},
		{"=startsWithEquals", "\"=startsWithEquals\""},
		{"has\ttab", "\"has\ttab\""},
		{"has\nnewline", "\"has\nnewline\""},
		{"has#hash", "\"has#hash\""},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			result := quoteEnvValue(tt.input)
			if result != tt.expected {
				t.Errorf("quoteEnvValue(%q) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}

// setupProjectForEnv creates a project for testing env command
func setupProjectForEnv(t *testing.T, projectName string) (string, func()) {
	t.Helper()

	projectDir, err := os.MkdirTemp("", "varnish-project-*")
	if err != nil {
		t.Fatalf("failed to create project dir: %v", err)
	}

	reg, _ := registry.Load()
	reg.Register(projectDir, projectName)
	if err := reg.Save(); err != nil {
		t.Fatalf("failed to save: %v", err)
	}

	cfg := project.New()
	cfg.Project = projectName
	cfg.Include = []string{"db.*", "api.*", "test.*", "key", "new.*"}
	if err := cfg.Save(); err != nil {
		t.Fatalf("failed to save: %v", err)
	}

	return projectDir, func() {
		os.RemoveAll(projectDir)
	}
}
