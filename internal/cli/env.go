// env.go implements the "varnish env" command.
//
// This file is used by:
//   - cli/root.go: dispatches "env" command here
//
// Generates a .env file from the store + project config.
// Options:
//
//	--output     Output file path (default: .env)
//	--dry-run    Print to stdout instead of writing file
//	--force      Overwrite existing .env file
package cli

import (
	"flag"
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/dk/varnish/internal/config"
	"github.com/dk/varnish/internal/domain"
)

func runEnv(args []string, stdout, stderr io.Writer) error {
	fs := flag.NewFlagSet("env", flag.ContinueOnError)
	fs.SetOutput(stderr)
	output := fs.String("output", ".env", "output file path")
	dryRun := fs.Bool("dry-run", false, "print to stdout instead of writing file")
	force := fs.Bool("force", false, "overwrite existing output file")

	if err := fs.Parse(args); err != nil {
		return err
	}

	// Load project config
	cfg, err := domain.LoadProjectConfig()
	if err != nil {
		return fmt.Errorf("load project config: %w", err)
	}
	if cfg == nil {
		return fmt.Errorf("no .varnish.yaml found (run 'varnish init' first)")
	}

	// Load store
	store, err := domain.LoadStore()
	if err != nil {
		return fmt.Errorf("load store: %w", err)
	}

	// Resolve variables
	resolver := domain.NewResolver(store, cfg)
	vars := resolver.Resolve()

	// Check for missing variables
	missing := resolver.MissingVars()
	if len(missing) > 0 {
		fmt.Fprintf(stderr, "warning: missing variables in store: %s\n", strings.Join(missing, ", "))
	}

	// Build output content
	var sb strings.Builder
	sb.WriteString("# Generated by varnish - do not edit manually\n")
	sb.WriteString("# Regenerate with: varnish env\n\n")

	for _, v := range vars {
		// Quote values that contain special characters
		value := quoteEnvValue(v.Value)
		sb.WriteString(fmt.Sprintf("%s=%s\n", v.EnvName, value))
	}

	content := sb.String()

	if *dryRun {
		fmt.Fprint(stdout, content)
		return nil
	}

	// Check if output file exists
	if _, err := os.Stat(*output); err == nil && !*force {
		return fmt.Errorf("%s already exists (use --force to overwrite)", *output)
	}

	// Write the file
	if err := os.WriteFile(*output, []byte(content), config.PermSecure); err != nil {
		return fmt.Errorf("write %s: %w", *output, err)
	}

	fmt.Fprintf(stdout, "wrote %s (%d variables)\n", *output, len(vars))
	return nil
}

// quoteEnvValue quotes a value if it contains spaces, quotes, or other special chars.
func quoteEnvValue(s string) string {
	// If empty or contains special characters, quote it
	needsQuotes := s == "" ||
		strings.ContainsAny(s, " \t\n\r\"'$`\\#") ||
		strings.HasPrefix(s, "=")

	if !needsQuotes {
		return s
	}

	// Use double quotes and escape internal double quotes and backslashes
	escaped := strings.ReplaceAll(s, "\\", "\\\\")
	escaped = strings.ReplaceAll(escaped, "\"", "\\\"")
	escaped = strings.ReplaceAll(escaped, "$", "\\$")
	escaped = strings.ReplaceAll(escaped, "`", "\\`")

	return "\"" + escaped + "\""
}
